From 983eb7f7598582839e01e7ee652bc89df74fcd1e Mon Sep 17 00:00:00 2001
From: NelloKudo <marshnelloosu@gmail.com>
Date: Sat, 8 Nov 2025 03:05:23 +0100
Subject: [PATCH 1/2] HACK: kernelbase: Delay CreateProcessInternalW for
 miniloader installers.

Miniloader installers (WeGame, Nikke..) fail to download their games due to a
race condition which is seemingly fixed by simply sleeping for 1 second.
Nikke's launcher additionally needs the delay to only be a thing *after* it's already launched.

Also added WINE_MINILOADER_NAME to use the hack also with
games not hardcoded in source (e.g. WINE_MINILOADER_NAME="nikkeminiloader.exe")
---
 dlls/kernelbase/process.c | 58 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 9d5c25f3cb4..d8d2281d6a5 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -720,6 +720,59 @@ static void sync_env_var_to_unix( WCHAR *env, const char *name )
     } else __wine_set_unix_env( name, NULL );
 }
 
+static BOOL is_miniloader(const WCHAR **out_name)
+{
+    static volatile char cache = -1;
+    static const WCHAR *cached_name = NULL;
+    
+    if (cache == -1)
+    {
+        const WCHAR *p, *name = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+        if ((p = wcsrchr(name, '/'))) name = p + 1;
+        if ((p = wcsrchr(name, '\\'))) name = p + 1;
+        
+        cached_name = name;
+        cache = 1;
+    }
+    
+    if (out_name) *out_name = cached_name;
+    return cache;
+}
+
+static void miniloader_hacks(volatile char *process_started)
+{
+    const WCHAR *name;
+    WCHAR env_exe[MAX_PATH];
+    DWORD len;
+
+    if (!is_miniloader(&name)) return;
+
+    len = GetEnvironmentVariableW(L"WINE_MINILOADER_NAME", env_exe, MAX_PATH);
+
+    if (!wcsicmp(name, L"nikkeminiloader.exe") ||
+        !wcsicmp(name, L"WeGameMiniLoader.exe") ||
+        !wcsicmp(name, L"wegame.exe") ||
+        (len > 0 && len < MAX_PATH && !wcsicmp(name, env_exe)))
+    {
+        FIXME( "HACK: miniloader detected, sleeping..\n" );
+        Sleep(1000);
+    }
+    else if (!wcsicmp(name, L"nikke_launcher.exe"))
+    {
+        /* We don't want the first boot of the launcher to have the delay,
+           just the processes launched after it (e.g. downloading) */
+        if (*process_started == -1)
+        {
+            *process_started = 0;
+        }
+        else
+        {
+            FIXME( "HACK: Nikke launcher detected, sleeping..\n" );
+            Sleep(2000);
+        }
+    }
+}
+
 /**********************************************************************
  *           CreateProcessInternalW   (kernelbase.@)
  */
@@ -741,6 +794,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
     ULONG nt_flags = 0;
     USHORT machine = 0;
     NTSTATUS status;
+    static volatile char process_started = -1;
 
     /* Process the AppName and/or CmdLine to get module name and path */
 
@@ -973,6 +1027,10 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
     RtlDestroyProcessParameters( params );
     if (tidy_cmdline != cmd_line) HeapFree( GetProcessHeap(), 0, tidy_cmdline );
     HeapFree( GetProcessHeap(), 0, product_name );
+
+    /* HACK: Sleep(1000) to fix race conditions in miniloader launchers */
+    miniloader_hacks(&process_started);
+
     return set_ntstatus( status );
 }
 
-- 
2.51.2

